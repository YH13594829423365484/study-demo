# 为什么再挂载后发接口请求？
1. 在组件挂载后发送请求可以确保数据在组件首次渲染时已经初始化。这对于依赖初始数据的组件非常重要，可以避免在数据未加载时出现空白或错误的 UI。
2. 在组件挂载后发送请求可以确保 DOM 已经渲染完毕，这样可以避免数据绑定或状态更新出现问题。

# 事件模型
1. DOM0,它没有事件流，不存在捕获和冒泡阶段，只会执行目标事件
2. DOM1,冒泡阶段执行事件
3. DOM2,捕获阶段直接执行事件

# 事件委托
事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。
 
使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

# instanceof 
instanceof运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置

# JSON
JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。
 
JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与
值的映射）。
 
JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。

# 同步和异步
同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  
 
异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 

# 同源策略
我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个
域的协议、域名、端口号必须相同，否则则不属于同一个域。
 
同源政策主要限制了三个方面
 
第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
 
第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
 
第三个是当前域下 ajax 无法发送跨域请求。
 
同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者
script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

# js的模块化规范
js 中现在比较成熟的有四种模块加载方案。
 
第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是
服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式
加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
 
第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定
义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。
 
第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js
的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60
 
第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

# 哪些操作会造成内存泄漏
1.意外的全局变量

2.被遗忘的计时器或回调函数

3.脱离 DOM 的引用

4.闭包

# 跨站脚本攻击（ XSS） 跨站请求伪造（CSRF）
# XSS
攻击者通过注入恶意脚本到受信任的网站中，使这些脚本在用户的浏览器中执行。这些脚本可以窃取用户信息、劫持用户会话、甚至传播恶意软件。

存储型XSS：
攻击者将恶意脚本存储在目标服务器上，例如通过提交表单或评论。
反射型XSS：
攻击者通过诱使用户点击一个包含恶意脚本的链接，将脚本发送到服务器。
DOM型XSS：
攻击者利用JavaScript代码中的漏洞，直接在客户端修改DOM树，使恶意脚本被执行。

防范措施
输入验证和过滤：对用户输入进行严格的验证和过滤，确保输入内容不包含恶意脚本。
输出编码：
在将用户输入输出到页面时，进行适当的编码，例如HTML实体编码。
内容安全策略（CSP）：
使用Content-Security-Policy HTTP头，限制页面可以加载的资源类型和来源。
HTTP-only Cookie：
设置Cookie的HttpOnly标志，防止JavaScript访问Cookie，从而减少会话劫持的风险。

# CSRF
攻击者诱导用户在已登录的状态下，向目标网站发送恶意请求。由于请求来自已认证的用户，服务器会误以为这是用户的真实操作。

用户在目标网站上登录，获得会话Cookie。用户在未退出目标网站的情况下，访问了攻击者控制的恶意网站。恶意网站包含一个隐藏的表单或脚本，自动提交一个请求到目标网站。目标网站收到请求时，会认为这是已认证用户的真实操作，从而执行相应的操作。

CSRF Token：
在每个表单中添加一个随机生成的CSRF Token，并在服务器端验证该Token。
服务器在处理请求时，检查请求中的CSRF Token是否与用户会话中的Token匹配。
双重提交Cookie：
在Cookie中设置一个随机值，并在表单中也包含相同的值。
服务器在处理请求时，检查表单中的值与Cookie中的值是否一致。

# 访问和修改dom节点的方法
使用 document.getElementById 方法可以通过元素的 ID 获取 DOM 节点。
使用 document.getElementsByTagName 方法可以通过标签名获取一组 DOM 节点。
使用 document.getElementsByClassName 方法可以通过类名获取一组 DOM 节点。
querySelector(selector)使用CSS选择器来获取第一个匹配的元素。
querySelectorAll(selectors)使用CSS选择器来获取所有匹配的元素，返回NodeList对象。
innerHTML设置或返回指定元素的HTML内容。
innerText 或 textContent设置或返回指定元素的文本内容。innerText考虑样式和布局，而textContent则不考虑。
setAttribute(name, value)设置指定元素的属性值。
removeAttribute(name)移除指定元素的属性。
classList.add/remove/toggle/contains操作元素的class列表。
appendChild(node)向元素的子节点列表的末尾添加一个新的子节点。
insertBefore(newNode, referenceNode)在指定的参考节点之前插入一个新节点。
replaceChild(newNode, oldNode)替换父节点的一个子节点。
removeChild(node)从DOM树中删除一个子节点。

# css动画

transition 属性在 CSS 中用于定义元素在不同状态之间平滑过渡的效果。它允许你控制属性变化的速度、持续时间和时间函数。

animation 它允许你定义动画的关键帧（@keyframes）并通过 animation 属性控制动画的各种细节，如持续时间、延迟、重复次数等。
animation-name: 动画名称
animation-duration: 动画持续时间
animation-timing-function: 动画计时函数
animation-delay: 动画延迟
animation-iteration-count: 动画迭代次数
animation-direction: 动画方向
animation-fill-mode: 动画填充模式
animation-play-state: 动画播放状态

transform 属性用于对元素进行旋转、缩放、移动或倾斜等变换操作
transform: translate(50px, 100px); （将元素向右移动 50px，向下移动 100px）
transform: scale(1.5, 2); （将元素的宽度放大 1.5 倍，高度放大 2 倍）
transform: rotate(45deg); （将元素顺时针旋转 45 度）
transform: skew(20deg, 10deg); （将元素在 x 轴上倾斜 20 度，在 y 轴上倾斜 10 度）

translate 通常比 position 更高效，主要原因在于它不会引起页面重排（reflow），而只会影响合成（compositing）
合成是指浏览器将多个图层组合在一起，形成最终的页面显示。图层是浏览器为了优化渲染性能而创建的独立绘制区域

# 媒体查询

# 插槽
默认插槽：用于在子组件中定义一个内容插入点，父组件可以通过这个插入点传递内容。
具名插槽：允许多个插槽的存在，并且每个插槽都有一个唯一的名称，父组件可以通过 v-slot 指令指定内容应该插入哪个具名插槽。
作用域插槽：允许子组件向父组件传递数据，父组件可以在插槽内容中使用这些数据。

# 单例
确保一个类只有一个实例，并提供一个全局访问点。
1. 立即执行函数
2. 闭包
3. class的静态方法